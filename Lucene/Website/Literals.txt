Literals From Wikibooks, open books for an open world < Java Programming Jump to navigation Jump to search Arithmetic expressions Java Programming Literals Methods Navigate Language Fundamentals topic: ( v • d • e ) Statements Conditional blocks Loop blocks Boolean expressions Variables Primitive Types Arithmetic expressions Literals Methods String Objects Packages Arrays Mathematical functions Large numbers Random numbers Unicode Comments Keywords Coding conventions Lambda expressions Java Literals are syntactic representations of boolean, character, numeric, or string data. Literals provide a means of expressing specific values in your program. For example, in the following statement, an integer variable named count is declared and assigned an integer value. The literal 0 represents, naturally enough, the value zero. Code section 3.61: Numeric literal. 1 int count = 0;
 The code section 3.62 contains two number literals followed by two boolean literals at line 1, one string literal followed by one number literal at line 2, and one string literal followed by one real number literal at line 3: Code section 3.62: Literals. 1 (2 > 3) ? true : false;
2 "text".substring(2);
3 System.out.println("Display a hard coded float: " + 37.19f);
 Boolean Literals[edit] There are two boolean literals true represents a true boolean value false represents a false boolean value There are no other boolean literals, because there are no other boolean values! Numeric Literals[edit] There are three types of numeric literals in Java. Integer Literals[edit] In Java, you may enter integer numbers in several formats: As decimal numbers such as 1995, 51966. Negative decimal numbers such as -42 are actually expressions consisting of the integer literal with the unary negation operation -. As octal numbers, using a leading 0 (zero) digit and one or more additional octal digits (digits between 0 and 7), such as 077. Octal numbers may evaluate to negative numbers; for example 037777777770 is actually the decimal value -8. As hexadecimal numbers, using the form 0x (or 0X) followed by one or more hexadecimal digits (digits from 0 to 9, a to f or A to F). For example, 0xCAFEBABEL is the long integer 3405691582. Like octal numbers, hexadecimal literals may represent negative numbers. Starting in J2SE 7.0, as binary numbers, using the form 0b (or 0B) followed by one or more binary digits (0 or 1). For example, 0b101010 is the integer 42. Like octal and hex numbers, binary literals may represent negative numbers. By default, the integer literal primitive type is int. If you want a long, add a letter el suffix (either the character l or the character L) to the integer literal. This suffix denotes a long integer rather than a standard integer. For example, 3405691582L is a long integer literal. Long integers are 8 bytes in length as opposed to the standard 4 bytes for int. It is best practice to use the suffix L instead of l to avoid confusion with the digit 1 (one) which looks like l in many fonts: 200l ≠ 2001. If you want a short integer literal, you have to cast it. Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits. Floating Point Literals[edit] Floating point numbers are expressed as decimal fractions or as exponential notation: Code section 3.63: Floating point literals. 1 double decimalNumber = 5.0;
2 decimalNumber = 89d;
3 decimalNumber = 0.5;
4 decimalNumber = 10f;
5 decimalNumber = 3.14159e0;
6 decimalNumber = 2.718281828459045D;
7 decimalNumber = 1.0e-6D;
 Floating point numbers consist of: an optional leading + or - sign, indicating a positive or negative value; if omitted, the value is positive, one of the following number formats integer digits (must be followed by either an exponent or a suffix or both, to distinguish it from an integer literal) integer digits . integer digits . integer digits . integer digits an optional exponent of the form the exponent indicator e or E an optional exponent sign + or - (the default being a positive exponent) integer digits representing the integer exponent value an optional floating point suffix: either f or F indicating a single precision (4 bytes) floating point number, or d or D indicating the number is a double precision floating point number (by default, thus the double precision (8 bytes) is default). Here, integer digits represents one or more of the digits 0 through 9. Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits. Character Literals[edit] Character literals are constant valued character expressions embedded in a Java program. Java characters are sixteen bit Unicode characters, ranging from 0 to 65535. Character literals are expressed in Java as a single quote, the character, and a closing single quote ('a', '7', '$', 'π'). Character literals have the type char, an unsigned integer primitive type. Character literals may be safely promoted to larger integer types such as int and long. Character literals used where a short or byte is called for must be cast to short or byte since truncation may occur. String Literals[edit] String literals consist of the double quote character (") (ASCII 34, hex 0x22), zero or more characters (including Unicode characters), followed by a terminating double quote character ("), such as: "Ceci est une string." So a string literal follows the following grammar: <STRING :
        "\""
        (    (~["\"","\\","\n","\r"])
        |("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            |["0"-"7"](["0"-"7"])?
            |["0"-"3"]["0"-"7"]["0"-"7"]
            )
        )
        )*
        "\"">
 Within string and character literals, the backslash character can be used to escape special characters, such as unicode escape sequences, or the following special characters: Name Character ASCII hex Backspace \b 8 0x08 TAB \t 9 0x09 NUL character \0 0 0x00 newline \n 10 0x0a carriage control \r 13 0xd double quote \" 34 0x22 single quote \' 39 0x27 backslash \\ 92 0x5c String literals may not contain unescaped newline or linefeed characters. However, the Java compiler will evaluate compile time expressions, so the following String expression results in a string with three lines of text: Code section 3.64: Multi-line string. 1 String text = "This is a String literal\n"
2             + "which spans not one and not two\n"
3             + "but three lines of text.\n";
 null[edit] null is a special Java literal which represents a null value: a value which does not refer to any object. It is an error to attempt to dereference the null value — Java will throw a NullPointerException. null is often used to represent uninitialized state. Mixed Mode Operations[edit] In concatenation operations, the values in brackets are concatenated first. Then the values are concatenated from the left to the right. Be careful when mixing character literals and integers in String concatenation operations: Code section 3.65: Concatenation operations. 1 int one = '1';
2 int zero = '0';
3 
4 System.out.println("120? " + one + '2' + zero);
 Console for Code section 3.66 120? 49248
 The unexpected results arise because '1' and '0' are converted twice. The expression is concatenated as such: "120? " + one + '2' + zero "120? " + 49 + '2' + 48 "120? 49" + '2' + 48 "120? 492" + 48 "120? 49248" one and zero are integers. So they store integer values. The integer value of '1' is 49 and the integer value of '0' is 48. So the first concatenation concatenates "120? " and 49. 49 is first converted into String, yielding "49" and the concatenation returns the string "120? 49". The second concatenation concatenates "120? 49" and '2'. '2' is converted into the String "2" and the concatenation returns the string "120? 492". The concatenation between "120? 492" and '0' returns the string "120? 49248". The code section 66 yields the desired result: Code section 3.66: Correct primitive type. 1 char one = '1';
2 char zero = '0';
3 
4 System.out.println("120? " + one + '2' + zero);
 Console for Code section 3.66 120? 120
 Test your knowledge Question 3.9: Consider the following code: Question 3.9: New concatenation operations. 1 int one = '1';
2 int zero = '0';
3 
4 System.out.println("  3? " + (one + '2' + zero));
5 System.out.println("102? " + 100 + '2' + 0);
6 System.out.println("102? " + (100 + '2' + 0));
 Console for Question 3.9   3? 147
102? 10020
102? 150
 Explain the results seen. Answer For the first line: " 3? " + (one + '2' + zero) " 3? " + (49 + '2' + 48) " 3? " + (99 + 48) " 3? " + 147 " 3? 147" For the second line: "102? " + 100 + '2' + 0 "102? 100" + '2' + 0 "102? 1002" + 0 "102? 10020" For the last line: "102? " + (100 + '2' + 0) "102? " + (150 + 0) "102? " + 150 "102? 150" Arithmetic expressions Java Programming Literals Methods Retrieved from "https://en.wikibooks.org/w/index.php?title=Java_Programming/Literals&oldid=3420958" Category: Book:Java Programming Navigation menu Personal tools Not logged in Discussion for this IP address Contributions Create account Log in Namespaces Book Discussion Variants Views Read Edit View history More Search Navigation Main Page Help Browse Cookbook Wikijunior Featured books Recent changes Donations Random book Using Wikibooks Community Reading room Community portal Bulletin Board Help out! Policies and guidelines Contact us Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page In other languages Add links Sister projects Wikipedia Wikiversity Wiktionary Wikiquote Wikisource Wikinews Wikivoyage Commons Wikidata Print/export Create a collection Download as PDF Printable version This page was last edited on 7 May 2018, at 20:45. Text is available under the Creative Commons Attribution-ShareAlike License.; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Privacy policy About Wikibooks Disclaimers Developers Cookie statement Mobile view